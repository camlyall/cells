// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             (unknown)
// source: cells-jobs.proto

package jobs

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedJobServiceServers     = make(map[string]JobServiceEnhancedServer)
	enhancedJobServiceServersLock = sync.RWMutex{}
)

type idJobServiceServer interface {
	ID() string
}
type JobServiceEnhancedServer interface {
	JobServiceServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(JobServiceServer)
	filter(context.Context) []JobServiceServer
}
type JobServiceEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []JobServiceServer
}

func (m *JobServiceEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *JobServiceEnhancedServerImpl) addHandler(srv JobServiceServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *JobServiceEnhancedServerImpl) filter(ctx context.Context) []JobServiceServer {
	var ret []JobServiceServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *JobServiceEnhancedServerImpl) PutJob(ctx context.Context, r *PutJobRequest) (*PutJobResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.PutJob(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method PutJob not implemented")
}

func (m *JobServiceEnhancedServerImpl) GetJob(ctx context.Context, r *GetJobRequest) (*GetJobResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.GetJob(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}

func (m *JobServiceEnhancedServerImpl) DeleteJob(ctx context.Context, r *DeleteJobRequest) (*DeleteJobResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.DeleteJob(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJob not implemented")
}

func (m *JobServiceEnhancedServerImpl) ListJobs(r *ListJobsRequest, s JobService_ListJobsServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.ListJobs(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method ListJobs not implemented")
}

func (m *JobServiceEnhancedServerImpl) PutTask(ctx context.Context, r *PutTaskRequest) (*PutTaskResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.PutTask(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method PutTask not implemented")
}

func (m *JobServiceEnhancedServerImpl) PutTaskStream(s JobService_PutTaskStreamServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.PutTaskStream(s)
	}
	return status.Errorf(codes.Unimplemented, "method PutTaskStream not implemented")
}

func (m *JobServiceEnhancedServerImpl) ListTasks(r *ListTasksRequest, s JobService_ListTasksServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.ListTasks(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method ListTasks not implemented")
}

func (m *JobServiceEnhancedServerImpl) DeleteTasks(ctx context.Context, r *DeleteTasksRequest) (*DeleteTasksResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.DeleteTasks(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTasks not implemented")
}

func (m *JobServiceEnhancedServerImpl) DetectStuckTasks(ctx context.Context, r *DetectStuckTasksRequest) (*DetectStuckTasksResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.DetectStuckTasks(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method DetectStuckTasks not implemented")
}
func (m *JobServiceEnhancedServerImpl) mustEmbedUnimplementedJobServiceServer() {}
func RegisterJobServiceEnhancedServer(s grpc.ServiceRegistrar, srv JobServiceServer) {
	idServer, ok := s.(idJobServiceServer)
	if ok {
		enhancedJobServiceServersLock.Lock()
		defer enhancedJobServiceServersLock.Unlock()
		instance, ok := enhancedJobServiceServers[idServer.ID()]
		if !ok {
			instance = &JobServiceEnhancedServerImpl{}
			enhancedJobServiceServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterJobServiceServer(s, instance)
	} else {
		RegisterJobServiceServer(s, srv)
	}
}

var (
	enhancedTaskServiceServers     = make(map[string]TaskServiceEnhancedServer)
	enhancedTaskServiceServersLock = sync.RWMutex{}
)

type idTaskServiceServer interface {
	ID() string
}
type TaskServiceEnhancedServer interface {
	TaskServiceServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(TaskServiceServer)
	filter(context.Context) []TaskServiceServer
}
type TaskServiceEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []TaskServiceServer
}

func (m *TaskServiceEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *TaskServiceEnhancedServerImpl) addHandler(srv TaskServiceServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *TaskServiceEnhancedServerImpl) filter(ctx context.Context) []TaskServiceServer {
	var ret []TaskServiceServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *TaskServiceEnhancedServerImpl) Control(ctx context.Context, r *CtrlCommand) (*CtrlCommandResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Control(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Control not implemented")
}
func (m *TaskServiceEnhancedServerImpl) mustEmbedUnimplementedTaskServiceServer() {}
func RegisterTaskServiceEnhancedServer(s grpc.ServiceRegistrar, srv TaskServiceServer) {
	idServer, ok := s.(idTaskServiceServer)
	if ok {
		enhancedTaskServiceServersLock.Lock()
		defer enhancedTaskServiceServersLock.Unlock()
		instance, ok := enhancedTaskServiceServers[idServer.ID()]
		if !ok {
			instance = &TaskServiceEnhancedServerImpl{}
			enhancedTaskServiceServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterTaskServiceServer(s, instance)
	} else {
		RegisterTaskServiceServer(s, srv)
	}
}
