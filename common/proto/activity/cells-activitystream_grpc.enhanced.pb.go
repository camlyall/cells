// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             (unknown)
// source: cells-activitystream.proto

package activity

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedActivityServiceServers     = make(map[string]ActivityServiceEnhancedServer)
	enhancedActivityServiceServersLock = sync.RWMutex{}
)

type idActivityServiceServer interface {
	ID() string
}
type ActivityServiceEnhancedServer interface {
	ActivityServiceServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(ActivityServiceServer)
	filter(context.Context) []ActivityServiceServer
}
type ActivityServiceEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []ActivityServiceServer
}

func (m *ActivityServiceEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *ActivityServiceEnhancedServerImpl) addHandler(srv ActivityServiceServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *ActivityServiceEnhancedServerImpl) filter(ctx context.Context) []ActivityServiceServer {
	var ret []ActivityServiceServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *ActivityServiceEnhancedServerImpl) PostActivity(s ActivityService_PostActivityServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.PostActivity(s)
	}
	return status.Errorf(codes.Unimplemented, "method PostActivity not implemented")
}

func (m *ActivityServiceEnhancedServerImpl) StreamActivities(r *StreamActivitiesRequest, s ActivityService_StreamActivitiesServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.StreamActivities(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method StreamActivities not implemented")
}

func (m *ActivityServiceEnhancedServerImpl) UnreadActivitiesNumber(ctx context.Context, r *UnreadActivitiesRequest) (*UnreadActivitiesResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.UnreadActivitiesNumber(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method UnreadActivitiesNumber not implemented")
}

func (m *ActivityServiceEnhancedServerImpl) PurgeActivities(ctx context.Context, r *PurgeActivitiesRequest) (*PurgeActivitiesResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.PurgeActivities(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method PurgeActivities not implemented")
}

func (m *ActivityServiceEnhancedServerImpl) SetUserLastActivity(ctx context.Context, r *UserLastActivityRequest) (*UserLastActivityResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.SetUserLastActivity(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method SetUserLastActivity not implemented")
}

func (m *ActivityServiceEnhancedServerImpl) Subscribe(ctx context.Context, r *SubscribeRequest) (*SubscribeResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Subscribe(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func (m *ActivityServiceEnhancedServerImpl) SearchSubscriptions(r *SearchSubscriptionsRequest, s ActivityService_SearchSubscriptionsServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.SearchSubscriptions(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method SearchSubscriptions not implemented")
}
func (m *ActivityServiceEnhancedServerImpl) mustEmbedUnimplementedActivityServiceServer() {}
func RegisterActivityServiceEnhancedServer(s grpc.ServiceRegistrar, srv ActivityServiceServer) {
	idServer, ok := s.(idActivityServiceServer)
	if ok {
		enhancedActivityServiceServersLock.Lock()
		defer enhancedActivityServiceServersLock.Unlock()
		instance, ok := enhancedActivityServiceServers[idServer.ID()]
		if !ok {
			instance = &ActivityServiceEnhancedServerImpl{}
			enhancedActivityServiceServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterActivityServiceServer(s, instance)
	} else {
		RegisterActivityServiceServer(s, srv)
	}
}
