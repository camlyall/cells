// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             (unknown)
// source: cells-tree.proto

package tree

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedNodeProviderServers     = make(map[string]NodeProviderEnhancedServer)
	enhancedNodeProviderServersLock = sync.RWMutex{}
)

type idNodeProviderServer interface {
	ID() string
}
type NodeProviderEnhancedServer interface {
	NodeProviderServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(NodeProviderServer)
	filter(context.Context) []NodeProviderServer
}
type NodeProviderEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []NodeProviderServer
}

func (m *NodeProviderEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *NodeProviderEnhancedServerImpl) addHandler(srv NodeProviderServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *NodeProviderEnhancedServerImpl) filter(ctx context.Context) []NodeProviderServer {
	var ret []NodeProviderServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *NodeProviderEnhancedServerImpl) ReadNode(ctx context.Context, r *ReadNodeRequest) (*ReadNodeResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.ReadNode(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method ReadNode not implemented")
}

func (m *NodeProviderEnhancedServerImpl) ListNodes(r *ListNodesRequest, s NodeProvider_ListNodesServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.ListNodes(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (m *NodeProviderEnhancedServerImpl) mustEmbedUnimplementedNodeProviderServer() {}
func RegisterNodeProviderEnhancedServer(s grpc.ServiceRegistrar, srv NodeProviderServer) {
	idServer, ok := s.(idNodeProviderServer)
	if ok {
		enhancedNodeProviderServersLock.Lock()
		defer enhancedNodeProviderServersLock.Unlock()
		instance, ok := enhancedNodeProviderServers[idServer.ID()]
		if !ok {
			instance = &NodeProviderEnhancedServerImpl{}
			enhancedNodeProviderServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterNodeProviderServer(s, instance)
	} else {
		RegisterNodeProviderServer(s, srv)
	}
}

var (
	enhancedNodeProviderStreamerServers     = make(map[string]NodeProviderStreamerEnhancedServer)
	enhancedNodeProviderStreamerServersLock = sync.RWMutex{}
)

type idNodeProviderStreamerServer interface {
	ID() string
}
type NodeProviderStreamerEnhancedServer interface {
	NodeProviderStreamerServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(NodeProviderStreamerServer)
	filter(context.Context) []NodeProviderStreamerServer
}
type NodeProviderStreamerEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []NodeProviderStreamerServer
}

func (m *NodeProviderStreamerEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *NodeProviderStreamerEnhancedServerImpl) addHandler(srv NodeProviderStreamerServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *NodeProviderStreamerEnhancedServerImpl) filter(ctx context.Context) []NodeProviderStreamerServer {
	var ret []NodeProviderStreamerServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *NodeProviderStreamerEnhancedServerImpl) ReadNodeStream(s NodeProviderStreamer_ReadNodeStreamServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.ReadNodeStream(s)
	}
	return status.Errorf(codes.Unimplemented, "method ReadNodeStream not implemented")
}
func (m *NodeProviderStreamerEnhancedServerImpl) mustEmbedUnimplementedNodeProviderStreamerServer() {}
func RegisterNodeProviderStreamerEnhancedServer(s grpc.ServiceRegistrar, srv NodeProviderStreamerServer) {
	idServer, ok := s.(idNodeProviderStreamerServer)
	if ok {
		enhancedNodeProviderStreamerServersLock.Lock()
		defer enhancedNodeProviderStreamerServersLock.Unlock()
		instance, ok := enhancedNodeProviderStreamerServers[idServer.ID()]
		if !ok {
			instance = &NodeProviderStreamerEnhancedServerImpl{}
			enhancedNodeProviderStreamerServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterNodeProviderStreamerServer(s, instance)
	} else {
		RegisterNodeProviderStreamerServer(s, srv)
	}
}

var (
	enhancedNodeChangesStreamerServers     = make(map[string]NodeChangesStreamerEnhancedServer)
	enhancedNodeChangesStreamerServersLock = sync.RWMutex{}
)

type idNodeChangesStreamerServer interface {
	ID() string
}
type NodeChangesStreamerEnhancedServer interface {
	NodeChangesStreamerServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(NodeChangesStreamerServer)
	filter(context.Context) []NodeChangesStreamerServer
}
type NodeChangesStreamerEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []NodeChangesStreamerServer
}

func (m *NodeChangesStreamerEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *NodeChangesStreamerEnhancedServerImpl) addHandler(srv NodeChangesStreamerServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *NodeChangesStreamerEnhancedServerImpl) filter(ctx context.Context) []NodeChangesStreamerServer {
	var ret []NodeChangesStreamerServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *NodeChangesStreamerEnhancedServerImpl) StreamChanges(r *StreamChangesRequest, s NodeChangesStreamer_StreamChangesServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.StreamChanges(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method StreamChanges not implemented")
}
func (m *NodeChangesStreamerEnhancedServerImpl) mustEmbedUnimplementedNodeChangesStreamerServer() {}
func RegisterNodeChangesStreamerEnhancedServer(s grpc.ServiceRegistrar, srv NodeChangesStreamerServer) {
	idServer, ok := s.(idNodeChangesStreamerServer)
	if ok {
		enhancedNodeChangesStreamerServersLock.Lock()
		defer enhancedNodeChangesStreamerServersLock.Unlock()
		instance, ok := enhancedNodeChangesStreamerServers[idServer.ID()]
		if !ok {
			instance = &NodeChangesStreamerEnhancedServerImpl{}
			enhancedNodeChangesStreamerServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterNodeChangesStreamerServer(s, instance)
	} else {
		RegisterNodeChangesStreamerServer(s, srv)
	}
}

var (
	enhancedNodeChangesReceiverStreamerServers     = make(map[string]NodeChangesReceiverStreamerEnhancedServer)
	enhancedNodeChangesReceiverStreamerServersLock = sync.RWMutex{}
)

type idNodeChangesReceiverStreamerServer interface {
	ID() string
}
type NodeChangesReceiverStreamerEnhancedServer interface {
	NodeChangesReceiverStreamerServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(NodeChangesReceiverStreamerServer)
	filter(context.Context) []NodeChangesReceiverStreamerServer
}
type NodeChangesReceiverStreamerEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []NodeChangesReceiverStreamerServer
}

func (m *NodeChangesReceiverStreamerEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *NodeChangesReceiverStreamerEnhancedServerImpl) addHandler(srv NodeChangesReceiverStreamerServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *NodeChangesReceiverStreamerEnhancedServerImpl) filter(ctx context.Context) []NodeChangesReceiverStreamerServer {
	var ret []NodeChangesReceiverStreamerServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *NodeChangesReceiverStreamerEnhancedServerImpl) PostNodeChanges(s NodeChangesReceiverStreamer_PostNodeChangesServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.PostNodeChanges(s)
	}
	return status.Errorf(codes.Unimplemented, "method PostNodeChanges not implemented")
}
func (m *NodeChangesReceiverStreamerEnhancedServerImpl) mustEmbedUnimplementedNodeChangesReceiverStreamerServer() {
}
func RegisterNodeChangesReceiverStreamerEnhancedServer(s grpc.ServiceRegistrar, srv NodeChangesReceiverStreamerServer) {
	idServer, ok := s.(idNodeChangesReceiverStreamerServer)
	if ok {
		enhancedNodeChangesReceiverStreamerServersLock.Lock()
		defer enhancedNodeChangesReceiverStreamerServersLock.Unlock()
		instance, ok := enhancedNodeChangesReceiverStreamerServers[idServer.ID()]
		if !ok {
			instance = &NodeChangesReceiverStreamerEnhancedServerImpl{}
			enhancedNodeChangesReceiverStreamerServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterNodeChangesReceiverStreamerServer(s, instance)
	} else {
		RegisterNodeChangesReceiverStreamerServer(s, srv)
	}
}

var (
	enhancedNodeReceiverServers     = make(map[string]NodeReceiverEnhancedServer)
	enhancedNodeReceiverServersLock = sync.RWMutex{}
)

type idNodeReceiverServer interface {
	ID() string
}
type NodeReceiverEnhancedServer interface {
	NodeReceiverServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(NodeReceiverServer)
	filter(context.Context) []NodeReceiverServer
}
type NodeReceiverEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []NodeReceiverServer
}

func (m *NodeReceiverEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *NodeReceiverEnhancedServerImpl) addHandler(srv NodeReceiverServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *NodeReceiverEnhancedServerImpl) filter(ctx context.Context) []NodeReceiverServer {
	var ret []NodeReceiverServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *NodeReceiverEnhancedServerImpl) CreateNode(ctx context.Context, r *CreateNodeRequest) (*CreateNodeResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CreateNode(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateNode not implemented")
}

func (m *NodeReceiverEnhancedServerImpl) UpdateNode(ctx context.Context, r *UpdateNodeRequest) (*UpdateNodeResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.UpdateNode(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNode not implemented")
}

func (m *NodeReceiverEnhancedServerImpl) DeleteNode(ctx context.Context, r *DeleteNodeRequest) (*DeleteNodeResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.DeleteNode(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNode not implemented")
}
func (m *NodeReceiverEnhancedServerImpl) mustEmbedUnimplementedNodeReceiverServer() {}
func RegisterNodeReceiverEnhancedServer(s grpc.ServiceRegistrar, srv NodeReceiverServer) {
	idServer, ok := s.(idNodeReceiverServer)
	if ok {
		enhancedNodeReceiverServersLock.Lock()
		defer enhancedNodeReceiverServersLock.Unlock()
		instance, ok := enhancedNodeReceiverServers[idServer.ID()]
		if !ok {
			instance = &NodeReceiverEnhancedServerImpl{}
			enhancedNodeReceiverServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterNodeReceiverServer(s, instance)
	} else {
		RegisterNodeReceiverServer(s, srv)
	}
}

var (
	enhancedNodeReceiverStreamServers     = make(map[string]NodeReceiverStreamEnhancedServer)
	enhancedNodeReceiverStreamServersLock = sync.RWMutex{}
)

type idNodeReceiverStreamServer interface {
	ID() string
}
type NodeReceiverStreamEnhancedServer interface {
	NodeReceiverStreamServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(NodeReceiverStreamServer)
	filter(context.Context) []NodeReceiverStreamServer
}
type NodeReceiverStreamEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []NodeReceiverStreamServer
}

func (m *NodeReceiverStreamEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *NodeReceiverStreamEnhancedServerImpl) addHandler(srv NodeReceiverStreamServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *NodeReceiverStreamEnhancedServerImpl) filter(ctx context.Context) []NodeReceiverStreamServer {
	var ret []NodeReceiverStreamServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *NodeReceiverStreamEnhancedServerImpl) CreateNodeStream(s NodeReceiverStream_CreateNodeStreamServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.CreateNodeStream(s)
	}
	return status.Errorf(codes.Unimplemented, "method CreateNodeStream not implemented")
}

func (m *NodeReceiverStreamEnhancedServerImpl) UpdateNodeStream(s NodeReceiverStream_UpdateNodeStreamServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.UpdateNodeStream(s)
	}
	return status.Errorf(codes.Unimplemented, "method UpdateNodeStream not implemented")
}

func (m *NodeReceiverStreamEnhancedServerImpl) DeleteNodeStream(s NodeReceiverStream_DeleteNodeStreamServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.DeleteNodeStream(s)
	}
	return status.Errorf(codes.Unimplemented, "method DeleteNodeStream not implemented")
}
func (m *NodeReceiverStreamEnhancedServerImpl) mustEmbedUnimplementedNodeReceiverStreamServer() {}
func RegisterNodeReceiverStreamEnhancedServer(s grpc.ServiceRegistrar, srv NodeReceiverStreamServer) {
	idServer, ok := s.(idNodeReceiverStreamServer)
	if ok {
		enhancedNodeReceiverStreamServersLock.Lock()
		defer enhancedNodeReceiverStreamServersLock.Unlock()
		instance, ok := enhancedNodeReceiverStreamServers[idServer.ID()]
		if !ok {
			instance = &NodeReceiverStreamEnhancedServerImpl{}
			enhancedNodeReceiverStreamServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterNodeReceiverStreamServer(s, instance)
	} else {
		RegisterNodeReceiverStreamServer(s, srv)
	}
}

var (
	enhancedSessionIndexerServers     = make(map[string]SessionIndexerEnhancedServer)
	enhancedSessionIndexerServersLock = sync.RWMutex{}
)

type idSessionIndexerServer interface {
	ID() string
}
type SessionIndexerEnhancedServer interface {
	SessionIndexerServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(SessionIndexerServer)
	filter(context.Context) []SessionIndexerServer
}
type SessionIndexerEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []SessionIndexerServer
}

func (m *SessionIndexerEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *SessionIndexerEnhancedServerImpl) addHandler(srv SessionIndexerServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *SessionIndexerEnhancedServerImpl) filter(ctx context.Context) []SessionIndexerServer {
	var ret []SessionIndexerServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *SessionIndexerEnhancedServerImpl) OpenSession(ctx context.Context, r *OpenSessionRequest) (*OpenSessionResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.OpenSession(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method OpenSession not implemented")
}

func (m *SessionIndexerEnhancedServerImpl) FlushSession(ctx context.Context, r *FlushSessionRequest) (*FlushSessionResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.FlushSession(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method FlushSession not implemented")
}

func (m *SessionIndexerEnhancedServerImpl) CloseSession(ctx context.Context, r *CloseSessionRequest) (*CloseSessionResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CloseSession(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CloseSession not implemented")
}
func (m *SessionIndexerEnhancedServerImpl) mustEmbedUnimplementedSessionIndexerServer() {}
func RegisterSessionIndexerEnhancedServer(s grpc.ServiceRegistrar, srv SessionIndexerServer) {
	idServer, ok := s.(idSessionIndexerServer)
	if ok {
		enhancedSessionIndexerServersLock.Lock()
		defer enhancedSessionIndexerServersLock.Unlock()
		instance, ok := enhancedSessionIndexerServers[idServer.ID()]
		if !ok {
			instance = &SessionIndexerEnhancedServerImpl{}
			enhancedSessionIndexerServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterSessionIndexerServer(s, instance)
	} else {
		RegisterSessionIndexerServer(s, srv)
	}
}

var (
	enhancedNodeEventsProviderServers     = make(map[string]NodeEventsProviderEnhancedServer)
	enhancedNodeEventsProviderServersLock = sync.RWMutex{}
)

type idNodeEventsProviderServer interface {
	ID() string
}
type NodeEventsProviderEnhancedServer interface {
	NodeEventsProviderServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(NodeEventsProviderServer)
	filter(context.Context) []NodeEventsProviderServer
}
type NodeEventsProviderEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []NodeEventsProviderServer
}

func (m *NodeEventsProviderEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *NodeEventsProviderEnhancedServerImpl) addHandler(srv NodeEventsProviderServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *NodeEventsProviderEnhancedServerImpl) filter(ctx context.Context) []NodeEventsProviderServer {
	var ret []NodeEventsProviderServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *NodeEventsProviderEnhancedServerImpl) WatchNode(r *WatchNodeRequest, s NodeEventsProvider_WatchNodeServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.WatchNode(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method WatchNode not implemented")
}
func (m *NodeEventsProviderEnhancedServerImpl) mustEmbedUnimplementedNodeEventsProviderServer() {}
func RegisterNodeEventsProviderEnhancedServer(s grpc.ServiceRegistrar, srv NodeEventsProviderServer) {
	idServer, ok := s.(idNodeEventsProviderServer)
	if ok {
		enhancedNodeEventsProviderServersLock.Lock()
		defer enhancedNodeEventsProviderServersLock.Unlock()
		instance, ok := enhancedNodeEventsProviderServers[idServer.ID()]
		if !ok {
			instance = &NodeEventsProviderEnhancedServerImpl{}
			enhancedNodeEventsProviderServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterNodeEventsProviderServer(s, instance)
	} else {
		RegisterNodeEventsProviderServer(s, srv)
	}
}

var (
	enhancedSearcherServers     = make(map[string]SearcherEnhancedServer)
	enhancedSearcherServersLock = sync.RWMutex{}
)

type idSearcherServer interface {
	ID() string
}
type SearcherEnhancedServer interface {
	SearcherServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(SearcherServer)
	filter(context.Context) []SearcherServer
}
type SearcherEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []SearcherServer
}

func (m *SearcherEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *SearcherEnhancedServerImpl) addHandler(srv SearcherServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *SearcherEnhancedServerImpl) filter(ctx context.Context) []SearcherServer {
	var ret []SearcherServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *SearcherEnhancedServerImpl) Search(r *SearchRequest, s Searcher_SearchServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.Search(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (m *SearcherEnhancedServerImpl) mustEmbedUnimplementedSearcherServer() {}
func RegisterSearcherEnhancedServer(s grpc.ServiceRegistrar, srv SearcherServer) {
	idServer, ok := s.(idSearcherServer)
	if ok {
		enhancedSearcherServersLock.Lock()
		defer enhancedSearcherServersLock.Unlock()
		instance, ok := enhancedSearcherServers[idServer.ID()]
		if !ok {
			instance = &SearcherEnhancedServerImpl{}
			enhancedSearcherServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterSearcherServer(s, instance)
	} else {
		RegisterSearcherServer(s, srv)
	}
}

var (
	enhancedNodeContentReaderServers     = make(map[string]NodeContentReaderEnhancedServer)
	enhancedNodeContentReaderServersLock = sync.RWMutex{}
)

type idNodeContentReaderServer interface {
	ID() string
}
type NodeContentReaderEnhancedServer interface {
	NodeContentReaderServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(NodeContentReaderServer)
	filter(context.Context) []NodeContentReaderServer
}
type NodeContentReaderEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []NodeContentReaderServer
}

func (m *NodeContentReaderEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *NodeContentReaderEnhancedServerImpl) addHandler(srv NodeContentReaderServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *NodeContentReaderEnhancedServerImpl) filter(ctx context.Context) []NodeContentReaderServer {
	var ret []NodeContentReaderServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}
func (m *NodeContentReaderEnhancedServerImpl) mustEmbedUnimplementedNodeContentReaderServer() {}
func RegisterNodeContentReaderEnhancedServer(s grpc.ServiceRegistrar, srv NodeContentReaderServer) {
	idServer, ok := s.(idNodeContentReaderServer)
	if ok {
		enhancedNodeContentReaderServersLock.Lock()
		defer enhancedNodeContentReaderServersLock.Unlock()
		instance, ok := enhancedNodeContentReaderServers[idServer.ID()]
		if !ok {
			instance = &NodeContentReaderEnhancedServerImpl{}
			enhancedNodeContentReaderServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterNodeContentReaderServer(s, instance)
	} else {
		RegisterNodeContentReaderServer(s, srv)
	}
}

var (
	enhancedNodeContentWriterServers     = make(map[string]NodeContentWriterEnhancedServer)
	enhancedNodeContentWriterServersLock = sync.RWMutex{}
)

type idNodeContentWriterServer interface {
	ID() string
}
type NodeContentWriterEnhancedServer interface {
	NodeContentWriterServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(NodeContentWriterServer)
	filter(context.Context) []NodeContentWriterServer
}
type NodeContentWriterEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []NodeContentWriterServer
}

func (m *NodeContentWriterEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *NodeContentWriterEnhancedServerImpl) addHandler(srv NodeContentWriterServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *NodeContentWriterEnhancedServerImpl) filter(ctx context.Context) []NodeContentWriterServer {
	var ret []NodeContentWriterServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}
func (m *NodeContentWriterEnhancedServerImpl) mustEmbedUnimplementedNodeContentWriterServer() {}
func RegisterNodeContentWriterEnhancedServer(s grpc.ServiceRegistrar, srv NodeContentWriterServer) {
	idServer, ok := s.(idNodeContentWriterServer)
	if ok {
		enhancedNodeContentWriterServersLock.Lock()
		defer enhancedNodeContentWriterServersLock.Unlock()
		instance, ok := enhancedNodeContentWriterServers[idServer.ID()]
		if !ok {
			instance = &NodeContentWriterEnhancedServerImpl{}
			enhancedNodeContentWriterServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterNodeContentWriterServer(s, instance)
	} else {
		RegisterNodeContentWriterServer(s, srv)
	}
}

var (
	enhancedNodeVersionerServers     = make(map[string]NodeVersionerEnhancedServer)
	enhancedNodeVersionerServersLock = sync.RWMutex{}
)

type idNodeVersionerServer interface {
	ID() string
}
type NodeVersionerEnhancedServer interface {
	NodeVersionerServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(NodeVersionerServer)
	filter(context.Context) []NodeVersionerServer
}
type NodeVersionerEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []NodeVersionerServer
}

func (m *NodeVersionerEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *NodeVersionerEnhancedServerImpl) addHandler(srv NodeVersionerServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *NodeVersionerEnhancedServerImpl) filter(ctx context.Context) []NodeVersionerServer {
	var ret []NodeVersionerServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *NodeVersionerEnhancedServerImpl) CreateVersion(ctx context.Context, r *CreateVersionRequest) (*CreateVersionResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CreateVersion(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateVersion not implemented")
}

func (m *NodeVersionerEnhancedServerImpl) StoreVersion(ctx context.Context, r *StoreVersionRequest) (*StoreVersionResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.StoreVersion(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method StoreVersion not implemented")
}

func (m *NodeVersionerEnhancedServerImpl) ListVersions(r *ListVersionsRequest, s NodeVersioner_ListVersionsServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.ListVersions(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method ListVersions not implemented")
}

func (m *NodeVersionerEnhancedServerImpl) HeadVersion(ctx context.Context, r *HeadVersionRequest) (*HeadVersionResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.HeadVersion(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method HeadVersion not implemented")
}

func (m *NodeVersionerEnhancedServerImpl) PruneVersions(ctx context.Context, r *PruneVersionsRequest) (*PruneVersionsResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.PruneVersions(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method PruneVersions not implemented")
}
func (m *NodeVersionerEnhancedServerImpl) mustEmbedUnimplementedNodeVersionerServer() {}
func RegisterNodeVersionerEnhancedServer(s grpc.ServiceRegistrar, srv NodeVersionerServer) {
	idServer, ok := s.(idNodeVersionerServer)
	if ok {
		enhancedNodeVersionerServersLock.Lock()
		defer enhancedNodeVersionerServersLock.Unlock()
		instance, ok := enhancedNodeVersionerServers[idServer.ID()]
		if !ok {
			instance = &NodeVersionerEnhancedServerImpl{}
			enhancedNodeVersionerServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterNodeVersionerServer(s, instance)
	} else {
		RegisterNodeVersionerServer(s, srv)
	}
}

var (
	enhancedFileKeyManagerServers     = make(map[string]FileKeyManagerEnhancedServer)
	enhancedFileKeyManagerServersLock = sync.RWMutex{}
)

type idFileKeyManagerServer interface {
	ID() string
}
type FileKeyManagerEnhancedServer interface {
	FileKeyManagerServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(FileKeyManagerServer)
	filter(context.Context) []FileKeyManagerServer
}
type FileKeyManagerEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []FileKeyManagerServer
}

func (m *FileKeyManagerEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *FileKeyManagerEnhancedServerImpl) addHandler(srv FileKeyManagerServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *FileKeyManagerEnhancedServerImpl) filter(ctx context.Context) []FileKeyManagerServer {
	var ret []FileKeyManagerServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *FileKeyManagerEnhancedServerImpl) GetEncryptionKey(ctx context.Context, r *GetEncryptionKeyRequest) (*GetEncryptionKeyResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.GetEncryptionKey(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetEncryptionKey not implemented")
}
func (m *FileKeyManagerEnhancedServerImpl) mustEmbedUnimplementedFileKeyManagerServer() {}
func RegisterFileKeyManagerEnhancedServer(s grpc.ServiceRegistrar, srv FileKeyManagerServer) {
	idServer, ok := s.(idFileKeyManagerServer)
	if ok {
		enhancedFileKeyManagerServersLock.Lock()
		defer enhancedFileKeyManagerServersLock.Unlock()
		instance, ok := enhancedFileKeyManagerServers[idServer.ID()]
		if !ok {
			instance = &FileKeyManagerEnhancedServerImpl{}
			enhancedFileKeyManagerServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterFileKeyManagerServer(s, instance)
	} else {
		RegisterFileKeyManagerServer(s, srv)
	}
}

var (
	enhancedSyncChangesServers     = make(map[string]SyncChangesEnhancedServer)
	enhancedSyncChangesServersLock = sync.RWMutex{}
)

type idSyncChangesServer interface {
	ID() string
}
type SyncChangesEnhancedServer interface {
	SyncChangesServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(SyncChangesServer)
	filter(context.Context) []SyncChangesServer
}
type SyncChangesEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []SyncChangesServer
}

func (m *SyncChangesEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *SyncChangesEnhancedServerImpl) addHandler(srv SyncChangesServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *SyncChangesEnhancedServerImpl) filter(ctx context.Context) []SyncChangesServer {
	var ret []SyncChangesServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *SyncChangesEnhancedServerImpl) Put(s SyncChanges_PutServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.Put(s)
	}
	return status.Errorf(codes.Unimplemented, "method Put not implemented")
}

func (m *SyncChangesEnhancedServerImpl) Search(r *SearchSyncChangeRequest, s SyncChanges_SearchServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.Search(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (m *SyncChangesEnhancedServerImpl) mustEmbedUnimplementedSyncChangesServer() {}
func RegisterSyncChangesEnhancedServer(s grpc.ServiceRegistrar, srv SyncChangesServer) {
	idServer, ok := s.(idSyncChangesServer)
	if ok {
		enhancedSyncChangesServersLock.Lock()
		defer enhancedSyncChangesServersLock.Unlock()
		instance, ok := enhancedSyncChangesServers[idServer.ID()]
		if !ok {
			instance = &SyncChangesEnhancedServerImpl{}
			enhancedSyncChangesServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterSyncChangesServer(s, instance)
	} else {
		RegisterSyncChangesServer(s, srv)
	}
}
