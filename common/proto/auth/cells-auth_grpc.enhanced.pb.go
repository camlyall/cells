// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             (unknown)
// source: cells-auth.proto

package auth

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedAuthTokenRevokerServers     = make(map[string]AuthTokenRevokerEnhancedServer)
	enhancedAuthTokenRevokerServersLock = sync.RWMutex{}
)

type idAuthTokenRevokerServer interface {
	ID() string
}
type AuthTokenRevokerEnhancedServer interface {
	AuthTokenRevokerServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(AuthTokenRevokerServer)
	filter(context.Context) []AuthTokenRevokerServer
}
type AuthTokenRevokerEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []AuthTokenRevokerServer
}

func (m *AuthTokenRevokerEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *AuthTokenRevokerEnhancedServerImpl) addHandler(srv AuthTokenRevokerServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *AuthTokenRevokerEnhancedServerImpl) filter(ctx context.Context) []AuthTokenRevokerServer {
	var ret []AuthTokenRevokerServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

// Revoker invalidates the current token and specifies if the invalidation is due to a refresh or a revokation

func (m *AuthTokenRevokerEnhancedServerImpl) Revoke(ctx context.Context, r *RevokeTokenRequest) (*RevokeTokenResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Revoke(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}
func (m *AuthTokenRevokerEnhancedServerImpl) mustEmbedUnimplementedAuthTokenRevokerServer() {}
func RegisterAuthTokenRevokerEnhancedServer(s grpc.ServiceRegistrar, srv AuthTokenRevokerServer) {
	idServer, ok := s.(idAuthTokenRevokerServer)
	if ok {
		enhancedAuthTokenRevokerServersLock.Lock()
		defer enhancedAuthTokenRevokerServersLock.Unlock()
		instance, ok := enhancedAuthTokenRevokerServers[idServer.ID()]
		if !ok {
			instance = &AuthTokenRevokerEnhancedServerImpl{}
			enhancedAuthTokenRevokerServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterAuthTokenRevokerServer(s, instance)
	} else {
		RegisterAuthTokenRevokerServer(s, srv)
	}
}

var (
	enhancedAuthTokenPrunerServers     = make(map[string]AuthTokenPrunerEnhancedServer)
	enhancedAuthTokenPrunerServersLock = sync.RWMutex{}
)

type idAuthTokenPrunerServer interface {
	ID() string
}
type AuthTokenPrunerEnhancedServer interface {
	AuthTokenPrunerServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(AuthTokenPrunerServer)
	filter(context.Context) []AuthTokenPrunerServer
}
type AuthTokenPrunerEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []AuthTokenPrunerServer
}

func (m *AuthTokenPrunerEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *AuthTokenPrunerEnhancedServerImpl) addHandler(srv AuthTokenPrunerServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *AuthTokenPrunerEnhancedServerImpl) filter(ctx context.Context) []AuthTokenPrunerServer {
	var ret []AuthTokenPrunerServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

// PruneTokens clear revoked tokens

func (m *AuthTokenPrunerEnhancedServerImpl) PruneTokens(ctx context.Context, r *PruneTokensRequest) (*PruneTokensResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.PruneTokens(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method PruneTokens not implemented")
}
func (m *AuthTokenPrunerEnhancedServerImpl) mustEmbedUnimplementedAuthTokenPrunerServer() {}
func RegisterAuthTokenPrunerEnhancedServer(s grpc.ServiceRegistrar, srv AuthTokenPrunerServer) {
	idServer, ok := s.(idAuthTokenPrunerServer)
	if ok {
		enhancedAuthTokenPrunerServersLock.Lock()
		defer enhancedAuthTokenPrunerServersLock.Unlock()
		instance, ok := enhancedAuthTokenPrunerServers[idServer.ID()]
		if !ok {
			instance = &AuthTokenPrunerEnhancedServerImpl{}
			enhancedAuthTokenPrunerServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterAuthTokenPrunerServer(s, instance)
	} else {
		RegisterAuthTokenPrunerServer(s, srv)
	}
}

var (
	enhancedLoginProviderServers     = make(map[string]LoginProviderEnhancedServer)
	enhancedLoginProviderServersLock = sync.RWMutex{}
)

type idLoginProviderServer interface {
	ID() string
}
type LoginProviderEnhancedServer interface {
	LoginProviderServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(LoginProviderServer)
	filter(context.Context) []LoginProviderServer
}
type LoginProviderEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []LoginProviderServer
}

func (m *LoginProviderEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *LoginProviderEnhancedServerImpl) addHandler(srv LoginProviderServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *LoginProviderEnhancedServerImpl) filter(ctx context.Context) []LoginProviderServer {
	var ret []LoginProviderServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *LoginProviderEnhancedServerImpl) GetLogin(ctx context.Context, r *GetLoginRequest) (*GetLoginResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.GetLogin(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetLogin not implemented")
}

func (m *LoginProviderEnhancedServerImpl) CreateLogin(ctx context.Context, r *CreateLoginRequest) (*CreateLoginResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CreateLogin(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateLogin not implemented")
}

func (m *LoginProviderEnhancedServerImpl) AcceptLogin(ctx context.Context, r *AcceptLoginRequest) (*AcceptLoginResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.AcceptLogin(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method AcceptLogin not implemented")
}
func (m *LoginProviderEnhancedServerImpl) mustEmbedUnimplementedLoginProviderServer() {}
func RegisterLoginProviderEnhancedServer(s grpc.ServiceRegistrar, srv LoginProviderServer) {
	idServer, ok := s.(idLoginProviderServer)
	if ok {
		enhancedLoginProviderServersLock.Lock()
		defer enhancedLoginProviderServersLock.Unlock()
		instance, ok := enhancedLoginProviderServers[idServer.ID()]
		if !ok {
			instance = &LoginProviderEnhancedServerImpl{}
			enhancedLoginProviderServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterLoginProviderServer(s, instance)
	} else {
		RegisterLoginProviderServer(s, srv)
	}
}

var (
	enhancedConsentProviderServers     = make(map[string]ConsentProviderEnhancedServer)
	enhancedConsentProviderServersLock = sync.RWMutex{}
)

type idConsentProviderServer interface {
	ID() string
}
type ConsentProviderEnhancedServer interface {
	ConsentProviderServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(ConsentProviderServer)
	filter(context.Context) []ConsentProviderServer
}
type ConsentProviderEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []ConsentProviderServer
}

func (m *ConsentProviderEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *ConsentProviderEnhancedServerImpl) addHandler(srv ConsentProviderServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *ConsentProviderEnhancedServerImpl) filter(ctx context.Context) []ConsentProviderServer {
	var ret []ConsentProviderServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *ConsentProviderEnhancedServerImpl) GetConsent(ctx context.Context, r *GetConsentRequest) (*GetConsentResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.GetConsent(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method GetConsent not implemented")
}

func (m *ConsentProviderEnhancedServerImpl) CreateConsent(ctx context.Context, r *CreateConsentRequest) (*CreateConsentResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CreateConsent(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateConsent not implemented")
}

func (m *ConsentProviderEnhancedServerImpl) AcceptConsent(ctx context.Context, r *AcceptConsentRequest) (*AcceptConsentResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.AcceptConsent(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method AcceptConsent not implemented")
}
func (m *ConsentProviderEnhancedServerImpl) mustEmbedUnimplementedConsentProviderServer() {}
func RegisterConsentProviderEnhancedServer(s grpc.ServiceRegistrar, srv ConsentProviderServer) {
	idServer, ok := s.(idConsentProviderServer)
	if ok {
		enhancedConsentProviderServersLock.Lock()
		defer enhancedConsentProviderServersLock.Unlock()
		instance, ok := enhancedConsentProviderServers[idServer.ID()]
		if !ok {
			instance = &ConsentProviderEnhancedServerImpl{}
			enhancedConsentProviderServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterConsentProviderServer(s, instance)
	} else {
		RegisterConsentProviderServer(s, srv)
	}
}

var (
	enhancedLogoutProviderServers     = make(map[string]LogoutProviderEnhancedServer)
	enhancedLogoutProviderServersLock = sync.RWMutex{}
)

type idLogoutProviderServer interface {
	ID() string
}
type LogoutProviderEnhancedServer interface {
	LogoutProviderServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(LogoutProviderServer)
	filter(context.Context) []LogoutProviderServer
}
type LogoutProviderEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []LogoutProviderServer
}

func (m *LogoutProviderEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *LogoutProviderEnhancedServerImpl) addHandler(srv LogoutProviderServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *LogoutProviderEnhancedServerImpl) filter(ctx context.Context) []LogoutProviderServer {
	var ret []LogoutProviderServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *LogoutProviderEnhancedServerImpl) CreateLogout(ctx context.Context, r *CreateLogoutRequest) (*CreateLogoutResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CreateLogout(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateLogout not implemented")
}

func (m *LogoutProviderEnhancedServerImpl) AcceptLogout(ctx context.Context, r *AcceptLogoutRequest) (*AcceptLogoutResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.AcceptLogout(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method AcceptLogout not implemented")
}
func (m *LogoutProviderEnhancedServerImpl) mustEmbedUnimplementedLogoutProviderServer() {}
func RegisterLogoutProviderEnhancedServer(s grpc.ServiceRegistrar, srv LogoutProviderServer) {
	idServer, ok := s.(idLogoutProviderServer)
	if ok {
		enhancedLogoutProviderServersLock.Lock()
		defer enhancedLogoutProviderServersLock.Unlock()
		instance, ok := enhancedLogoutProviderServers[idServer.ID()]
		if !ok {
			instance = &LogoutProviderEnhancedServerImpl{}
			enhancedLogoutProviderServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterLogoutProviderServer(s, instance)
	} else {
		RegisterLogoutProviderServer(s, srv)
	}
}

var (
	enhancedAuthCodeProviderServers     = make(map[string]AuthCodeProviderEnhancedServer)
	enhancedAuthCodeProviderServersLock = sync.RWMutex{}
)

type idAuthCodeProviderServer interface {
	ID() string
}
type AuthCodeProviderEnhancedServer interface {
	AuthCodeProviderServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(AuthCodeProviderServer)
	filter(context.Context) []AuthCodeProviderServer
}
type AuthCodeProviderEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []AuthCodeProviderServer
}

func (m *AuthCodeProviderEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *AuthCodeProviderEnhancedServerImpl) addHandler(srv AuthCodeProviderServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *AuthCodeProviderEnhancedServerImpl) filter(ctx context.Context) []AuthCodeProviderServer {
	var ret []AuthCodeProviderServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *AuthCodeProviderEnhancedServerImpl) CreateAuthCode(ctx context.Context, r *CreateAuthCodeRequest) (*CreateAuthCodeResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CreateAuthCode(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuthCode not implemented")
}
func (m *AuthCodeProviderEnhancedServerImpl) mustEmbedUnimplementedAuthCodeProviderServer() {}
func RegisterAuthCodeProviderEnhancedServer(s grpc.ServiceRegistrar, srv AuthCodeProviderServer) {
	idServer, ok := s.(idAuthCodeProviderServer)
	if ok {
		enhancedAuthCodeProviderServersLock.Lock()
		defer enhancedAuthCodeProviderServersLock.Unlock()
		instance, ok := enhancedAuthCodeProviderServers[idServer.ID()]
		if !ok {
			instance = &AuthCodeProviderEnhancedServerImpl{}
			enhancedAuthCodeProviderServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterAuthCodeProviderServer(s, instance)
	} else {
		RegisterAuthCodeProviderServer(s, srv)
	}
}

var (
	enhancedAuthTokenVerifierServers     = make(map[string]AuthTokenVerifierEnhancedServer)
	enhancedAuthTokenVerifierServersLock = sync.RWMutex{}
)

type idAuthTokenVerifierServer interface {
	ID() string
}
type AuthTokenVerifierEnhancedServer interface {
	AuthTokenVerifierServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(AuthTokenVerifierServer)
	filter(context.Context) []AuthTokenVerifierServer
}
type AuthTokenVerifierEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []AuthTokenVerifierServer
}

func (m *AuthTokenVerifierEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *AuthTokenVerifierEnhancedServerImpl) addHandler(srv AuthTokenVerifierServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *AuthTokenVerifierEnhancedServerImpl) filter(ctx context.Context) []AuthTokenVerifierServer {
	var ret []AuthTokenVerifierServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

// Verifies a token and returns claims

func (m *AuthTokenVerifierEnhancedServerImpl) Verify(ctx context.Context, r *VerifyTokenRequest) (*VerifyTokenResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Verify(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (m *AuthTokenVerifierEnhancedServerImpl) mustEmbedUnimplementedAuthTokenVerifierServer() {}
func RegisterAuthTokenVerifierEnhancedServer(s grpc.ServiceRegistrar, srv AuthTokenVerifierServer) {
	idServer, ok := s.(idAuthTokenVerifierServer)
	if ok {
		enhancedAuthTokenVerifierServersLock.Lock()
		defer enhancedAuthTokenVerifierServersLock.Unlock()
		instance, ok := enhancedAuthTokenVerifierServers[idServer.ID()]
		if !ok {
			instance = &AuthTokenVerifierEnhancedServerImpl{}
			enhancedAuthTokenVerifierServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterAuthTokenVerifierServer(s, instance)
	} else {
		RegisterAuthTokenVerifierServer(s, srv)
	}
}

var (
	enhancedAuthCodeExchangerServers     = make(map[string]AuthCodeExchangerEnhancedServer)
	enhancedAuthCodeExchangerServersLock = sync.RWMutex{}
)

type idAuthCodeExchangerServer interface {
	ID() string
}
type AuthCodeExchangerEnhancedServer interface {
	AuthCodeExchangerServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(AuthCodeExchangerServer)
	filter(context.Context) []AuthCodeExchangerServer
}
type AuthCodeExchangerEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []AuthCodeExchangerServer
}

func (m *AuthCodeExchangerEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *AuthCodeExchangerEnhancedServerImpl) addHandler(srv AuthCodeExchangerServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *AuthCodeExchangerEnhancedServerImpl) filter(ctx context.Context) []AuthCodeExchangerServer {
	var ret []AuthCodeExchangerServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *AuthCodeExchangerEnhancedServerImpl) Exchange(ctx context.Context, r *ExchangeRequest) (*ExchangeResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Exchange(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Exchange not implemented")
}
func (m *AuthCodeExchangerEnhancedServerImpl) mustEmbedUnimplementedAuthCodeExchangerServer() {}
func RegisterAuthCodeExchangerEnhancedServer(s grpc.ServiceRegistrar, srv AuthCodeExchangerServer) {
	idServer, ok := s.(idAuthCodeExchangerServer)
	if ok {
		enhancedAuthCodeExchangerServersLock.Lock()
		defer enhancedAuthCodeExchangerServersLock.Unlock()
		instance, ok := enhancedAuthCodeExchangerServers[idServer.ID()]
		if !ok {
			instance = &AuthCodeExchangerEnhancedServerImpl{}
			enhancedAuthCodeExchangerServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterAuthCodeExchangerServer(s, instance)
	} else {
		RegisterAuthCodeExchangerServer(s, srv)
	}
}

var (
	enhancedPasswordCredentialsCodeServers     = make(map[string]PasswordCredentialsCodeEnhancedServer)
	enhancedPasswordCredentialsCodeServersLock = sync.RWMutex{}
)

type idPasswordCredentialsCodeServer interface {
	ID() string
}
type PasswordCredentialsCodeEnhancedServer interface {
	PasswordCredentialsCodeServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(PasswordCredentialsCodeServer)
	filter(context.Context) []PasswordCredentialsCodeServer
}
type PasswordCredentialsCodeEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []PasswordCredentialsCodeServer
}

func (m *PasswordCredentialsCodeEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *PasswordCredentialsCodeEnhancedServerImpl) addHandler(srv PasswordCredentialsCodeServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *PasswordCredentialsCodeEnhancedServerImpl) filter(ctx context.Context) []PasswordCredentialsCodeServer {
	var ret []PasswordCredentialsCodeServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *PasswordCredentialsCodeEnhancedServerImpl) PasswordCredentialsCode(ctx context.Context, r *PasswordCredentialsCodeRequest) (*PasswordCredentialsCodeResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.PasswordCredentialsCode(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method PasswordCredentialsCode not implemented")
}
func (m *PasswordCredentialsCodeEnhancedServerImpl) mustEmbedUnimplementedPasswordCredentialsCodeServer() {
}
func RegisterPasswordCredentialsCodeEnhancedServer(s grpc.ServiceRegistrar, srv PasswordCredentialsCodeServer) {
	idServer, ok := s.(idPasswordCredentialsCodeServer)
	if ok {
		enhancedPasswordCredentialsCodeServersLock.Lock()
		defer enhancedPasswordCredentialsCodeServersLock.Unlock()
		instance, ok := enhancedPasswordCredentialsCodeServers[idServer.ID()]
		if !ok {
			instance = &PasswordCredentialsCodeEnhancedServerImpl{}
			enhancedPasswordCredentialsCodeServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterPasswordCredentialsCodeServer(s, instance)
	} else {
		RegisterPasswordCredentialsCodeServer(s, srv)
	}
}

var (
	enhancedPasswordCredentialsTokenServers     = make(map[string]PasswordCredentialsTokenEnhancedServer)
	enhancedPasswordCredentialsTokenServersLock = sync.RWMutex{}
)

type idPasswordCredentialsTokenServer interface {
	ID() string
}
type PasswordCredentialsTokenEnhancedServer interface {
	PasswordCredentialsTokenServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(PasswordCredentialsTokenServer)
	filter(context.Context) []PasswordCredentialsTokenServer
}
type PasswordCredentialsTokenEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []PasswordCredentialsTokenServer
}

func (m *PasswordCredentialsTokenEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *PasswordCredentialsTokenEnhancedServerImpl) addHandler(srv PasswordCredentialsTokenServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *PasswordCredentialsTokenEnhancedServerImpl) filter(ctx context.Context) []PasswordCredentialsTokenServer {
	var ret []PasswordCredentialsTokenServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *PasswordCredentialsTokenEnhancedServerImpl) PasswordCredentialsToken(ctx context.Context, r *PasswordCredentialsTokenRequest) (*PasswordCredentialsTokenResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.PasswordCredentialsToken(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method PasswordCredentialsToken not implemented")
}
func (m *PasswordCredentialsTokenEnhancedServerImpl) mustEmbedUnimplementedPasswordCredentialsTokenServer() {
}
func RegisterPasswordCredentialsTokenEnhancedServer(s grpc.ServiceRegistrar, srv PasswordCredentialsTokenServer) {
	idServer, ok := s.(idPasswordCredentialsTokenServer)
	if ok {
		enhancedPasswordCredentialsTokenServersLock.Lock()
		defer enhancedPasswordCredentialsTokenServersLock.Unlock()
		instance, ok := enhancedPasswordCredentialsTokenServers[idServer.ID()]
		if !ok {
			instance = &PasswordCredentialsTokenEnhancedServerImpl{}
			enhancedPasswordCredentialsTokenServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterPasswordCredentialsTokenServer(s, instance)
	} else {
		RegisterPasswordCredentialsTokenServer(s, srv)
	}
}

var (
	enhancedAuthTokenRefresherServers     = make(map[string]AuthTokenRefresherEnhancedServer)
	enhancedAuthTokenRefresherServersLock = sync.RWMutex{}
)

type idAuthTokenRefresherServer interface {
	ID() string
}
type AuthTokenRefresherEnhancedServer interface {
	AuthTokenRefresherServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(AuthTokenRefresherServer)
	filter(context.Context) []AuthTokenRefresherServer
}
type AuthTokenRefresherEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []AuthTokenRefresherServer
}

func (m *AuthTokenRefresherEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *AuthTokenRefresherEnhancedServerImpl) addHandler(srv AuthTokenRefresherServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *AuthTokenRefresherEnhancedServerImpl) filter(ctx context.Context) []AuthTokenRefresherServer {
	var ret []AuthTokenRefresherServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *AuthTokenRefresherEnhancedServerImpl) Refresh(ctx context.Context, r *RefreshTokenRequest) (*RefreshTokenResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Refresh(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (m *AuthTokenRefresherEnhancedServerImpl) mustEmbedUnimplementedAuthTokenRefresherServer() {}
func RegisterAuthTokenRefresherEnhancedServer(s grpc.ServiceRegistrar, srv AuthTokenRefresherServer) {
	idServer, ok := s.(idAuthTokenRefresherServer)
	if ok {
		enhancedAuthTokenRefresherServersLock.Lock()
		defer enhancedAuthTokenRefresherServersLock.Unlock()
		instance, ok := enhancedAuthTokenRefresherServers[idServer.ID()]
		if !ok {
			instance = &AuthTokenRefresherEnhancedServerImpl{}
			enhancedAuthTokenRefresherServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterAuthTokenRefresherServer(s, instance)
	} else {
		RegisterAuthTokenRefresherServer(s, srv)
	}
}

var (
	enhancedPersonalAccessTokenServiceServers     = make(map[string]PersonalAccessTokenServiceEnhancedServer)
	enhancedPersonalAccessTokenServiceServersLock = sync.RWMutex{}
)

type idPersonalAccessTokenServiceServer interface {
	ID() string
}
type PersonalAccessTokenServiceEnhancedServer interface {
	PersonalAccessTokenServiceServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(PersonalAccessTokenServiceServer)
	filter(context.Context) []PersonalAccessTokenServiceServer
}
type PersonalAccessTokenServiceEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []PersonalAccessTokenServiceServer
}

func (m *PersonalAccessTokenServiceEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *PersonalAccessTokenServiceEnhancedServerImpl) addHandler(srv PersonalAccessTokenServiceServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *PersonalAccessTokenServiceEnhancedServerImpl) filter(ctx context.Context) []PersonalAccessTokenServiceServer {
	var ret []PersonalAccessTokenServiceServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *PersonalAccessTokenServiceEnhancedServerImpl) Generate(ctx context.Context, r *PatGenerateRequest) (*PatGenerateResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Generate(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Generate not implemented")
}

func (m *PersonalAccessTokenServiceEnhancedServerImpl) Revoke(ctx context.Context, r *PatRevokeRequest) (*PatRevokeResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Revoke(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Revoke not implemented")
}

func (m *PersonalAccessTokenServiceEnhancedServerImpl) List(ctx context.Context, r *PatListRequest) (*PatListResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.List(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (m *PersonalAccessTokenServiceEnhancedServerImpl) mustEmbedUnimplementedPersonalAccessTokenServiceServer() {
}
func RegisterPersonalAccessTokenServiceEnhancedServer(s grpc.ServiceRegistrar, srv PersonalAccessTokenServiceServer) {
	idServer, ok := s.(idPersonalAccessTokenServiceServer)
	if ok {
		enhancedPersonalAccessTokenServiceServersLock.Lock()
		defer enhancedPersonalAccessTokenServiceServersLock.Unlock()
		instance, ok := enhancedPersonalAccessTokenServiceServers[idServer.ID()]
		if !ok {
			instance = &PersonalAccessTokenServiceEnhancedServerImpl{}
			enhancedPersonalAccessTokenServiceServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterPersonalAccessTokenServiceServer(s, instance)
	} else {
		RegisterPersonalAccessTokenServiceServer(s, srv)
	}
}
