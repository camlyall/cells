// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             (unknown)
// source: cells-idm.proto

package idm

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedRoleServiceServers     = make(map[string]RoleServiceEnhancedServer)
	enhancedRoleServiceServersLock = sync.RWMutex{}
)

type idRoleServiceServer interface {
	ID() string
}
type RoleServiceEnhancedServer interface {
	RoleServiceServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(RoleServiceServer)
	filter(context.Context) []RoleServiceServer
}
type RoleServiceEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []RoleServiceServer
}

func (m *RoleServiceEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *RoleServiceEnhancedServerImpl) addHandler(srv RoleServiceServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *RoleServiceEnhancedServerImpl) filter(ctx context.Context) []RoleServiceServer {
	var ret []RoleServiceServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *RoleServiceEnhancedServerImpl) CreateRole(ctx context.Context, r *CreateRoleRequest) (*CreateRoleResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CreateRole(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateRole not implemented")
}

func (m *RoleServiceEnhancedServerImpl) DeleteRole(ctx context.Context, r *DeleteRoleRequest) (*DeleteRoleResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.DeleteRole(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}

func (m *RoleServiceEnhancedServerImpl) SearchRole(r *SearchRoleRequest, s RoleService_SearchRoleServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.SearchRole(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method SearchRole not implemented")
}

func (m *RoleServiceEnhancedServerImpl) StreamRole(s RoleService_StreamRoleServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.StreamRole(s)
	}
	return status.Errorf(codes.Unimplemented, "method StreamRole not implemented")
}

func (m *RoleServiceEnhancedServerImpl) CountRole(ctx context.Context, r *SearchRoleRequest) (*CountRoleResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CountRole(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CountRole not implemented")
}
func (m *RoleServiceEnhancedServerImpl) mustEmbedUnimplementedRoleServiceServer() {}
func RegisterRoleServiceEnhancedServer(s grpc.ServiceRegistrar, srv RoleServiceServer) {
	idServer, ok := s.(idRoleServiceServer)
	if ok {
		enhancedRoleServiceServersLock.Lock()
		defer enhancedRoleServiceServersLock.Unlock()
		instance, ok := enhancedRoleServiceServers[idServer.ID()]
		if !ok {
			instance = &RoleServiceEnhancedServerImpl{}
			enhancedRoleServiceServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterRoleServiceServer(s, instance)
	} else {
		RegisterRoleServiceServer(s, srv)
	}
}

var (
	enhancedUserServiceServers     = make(map[string]UserServiceEnhancedServer)
	enhancedUserServiceServersLock = sync.RWMutex{}
)

type idUserServiceServer interface {
	ID() string
}
type UserServiceEnhancedServer interface {
	UserServiceServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(UserServiceServer)
	filter(context.Context) []UserServiceServer
}
type UserServiceEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []UserServiceServer
}

func (m *UserServiceEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *UserServiceEnhancedServerImpl) addHandler(srv UserServiceServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *UserServiceEnhancedServerImpl) filter(ctx context.Context) []UserServiceServer {
	var ret []UserServiceServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *UserServiceEnhancedServerImpl) CreateUser(ctx context.Context, r *CreateUserRequest) (*CreateUserResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CreateUser(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}

func (m *UserServiceEnhancedServerImpl) DeleteUser(ctx context.Context, r *DeleteUserRequest) (*DeleteUserResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.DeleteUser(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}

func (m *UserServiceEnhancedServerImpl) BindUser(ctx context.Context, r *BindUserRequest) (*BindUserResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.BindUser(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method BindUser not implemented")
}

func (m *UserServiceEnhancedServerImpl) CountUser(ctx context.Context, r *SearchUserRequest) (*CountUserResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CountUser(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CountUser not implemented")
}

func (m *UserServiceEnhancedServerImpl) SearchUser(r *SearchUserRequest, s UserService_SearchUserServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.SearchUser(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method SearchUser not implemented")
}

func (m *UserServiceEnhancedServerImpl) StreamUser(s UserService_StreamUserServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.StreamUser(s)
	}
	return status.Errorf(codes.Unimplemented, "method StreamUser not implemented")
}
func (m *UserServiceEnhancedServerImpl) mustEmbedUnimplementedUserServiceServer() {}
func RegisterUserServiceEnhancedServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	idServer, ok := s.(idUserServiceServer)
	if ok {
		enhancedUserServiceServersLock.Lock()
		defer enhancedUserServiceServersLock.Unlock()
		instance, ok := enhancedUserServiceServers[idServer.ID()]
		if !ok {
			instance = &UserServiceEnhancedServerImpl{}
			enhancedUserServiceServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterUserServiceServer(s, instance)
	} else {
		RegisterUserServiceServer(s, srv)
	}
}

var (
	enhancedWorkspaceServiceServers     = make(map[string]WorkspaceServiceEnhancedServer)
	enhancedWorkspaceServiceServersLock = sync.RWMutex{}
)

type idWorkspaceServiceServer interface {
	ID() string
}
type WorkspaceServiceEnhancedServer interface {
	WorkspaceServiceServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(WorkspaceServiceServer)
	filter(context.Context) []WorkspaceServiceServer
}
type WorkspaceServiceEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []WorkspaceServiceServer
}

func (m *WorkspaceServiceEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *WorkspaceServiceEnhancedServerImpl) addHandler(srv WorkspaceServiceServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *WorkspaceServiceEnhancedServerImpl) filter(ctx context.Context) []WorkspaceServiceServer {
	var ret []WorkspaceServiceServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *WorkspaceServiceEnhancedServerImpl) CreateWorkspace(ctx context.Context, r *CreateWorkspaceRequest) (*CreateWorkspaceResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CreateWorkspace(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateWorkspace not implemented")
}

func (m *WorkspaceServiceEnhancedServerImpl) DeleteWorkspace(ctx context.Context, r *DeleteWorkspaceRequest) (*DeleteWorkspaceResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.DeleteWorkspace(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkspace not implemented")
}

func (m *WorkspaceServiceEnhancedServerImpl) SearchWorkspace(r *SearchWorkspaceRequest, s WorkspaceService_SearchWorkspaceServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.SearchWorkspace(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method SearchWorkspace not implemented")
}

func (m *WorkspaceServiceEnhancedServerImpl) StreamWorkspace(s WorkspaceService_StreamWorkspaceServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.StreamWorkspace(s)
	}
	return status.Errorf(codes.Unimplemented, "method StreamWorkspace not implemented")
}
func (m *WorkspaceServiceEnhancedServerImpl) mustEmbedUnimplementedWorkspaceServiceServer() {}
func RegisterWorkspaceServiceEnhancedServer(s grpc.ServiceRegistrar, srv WorkspaceServiceServer) {
	idServer, ok := s.(idWorkspaceServiceServer)
	if ok {
		enhancedWorkspaceServiceServersLock.Lock()
		defer enhancedWorkspaceServiceServersLock.Unlock()
		instance, ok := enhancedWorkspaceServiceServers[idServer.ID()]
		if !ok {
			instance = &WorkspaceServiceEnhancedServerImpl{}
			enhancedWorkspaceServiceServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterWorkspaceServiceServer(s, instance)
	} else {
		RegisterWorkspaceServiceServer(s, srv)
	}
}

var (
	enhancedACLServiceServers     = make(map[string]ACLServiceEnhancedServer)
	enhancedACLServiceServersLock = sync.RWMutex{}
)

type idACLServiceServer interface {
	ID() string
}
type ACLServiceEnhancedServer interface {
	ACLServiceServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(ACLServiceServer)
	filter(context.Context) []ACLServiceServer
}
type ACLServiceEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []ACLServiceServer
}

func (m *ACLServiceEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *ACLServiceEnhancedServerImpl) addHandler(srv ACLServiceServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *ACLServiceEnhancedServerImpl) filter(ctx context.Context) []ACLServiceServer {
	var ret []ACLServiceServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

// Insert a new ACL

func (m *ACLServiceEnhancedServerImpl) CreateACL(ctx context.Context, r *CreateACLRequest) (*CreateACLResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.CreateACL(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method CreateACL not implemented")
}

// Set an expiration date that invalidates an ACL without deleting it

func (m *ACLServiceEnhancedServerImpl) ExpireACL(ctx context.Context, r *ExpireACLRequest) (*ExpireACLResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.ExpireACL(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method ExpireACL not implemented")
}

// Definitely delete an ACL

func (m *ACLServiceEnhancedServerImpl) DeleteACL(ctx context.Context, r *DeleteACLRequest) (*DeleteACLResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.DeleteACL(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeleteACL not implemented")
}

// Search ACLs by Query or Expiration period

func (m *ACLServiceEnhancedServerImpl) SearchACL(r *SearchACLRequest, s ACLService_SearchACLServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.SearchACL(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method SearchACL not implemented")
}

// Stream version of Search ACL

func (m *ACLServiceEnhancedServerImpl) StreamACL(s ACLService_StreamACLServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.StreamACL(s)
	}
	return status.Errorf(codes.Unimplemented, "method StreamACL not implemented")
}

// Restore ACLs based on Query and Expiration period

func (m *ACLServiceEnhancedServerImpl) RestoreACL(ctx context.Context, r *RestoreACLRequest) (*RestoreACLResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.RestoreACL(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method RestoreACL not implemented")
}
func (m *ACLServiceEnhancedServerImpl) mustEmbedUnimplementedACLServiceServer() {}
func RegisterACLServiceEnhancedServer(s grpc.ServiceRegistrar, srv ACLServiceServer) {
	idServer, ok := s.(idACLServiceServer)
	if ok {
		enhancedACLServiceServersLock.Lock()
		defer enhancedACLServiceServersLock.Unlock()
		instance, ok := enhancedACLServiceServers[idServer.ID()]
		if !ok {
			instance = &ACLServiceEnhancedServerImpl{}
			enhancedACLServiceServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterACLServiceServer(s, instance)
	} else {
		RegisterACLServiceServer(s, srv)
	}
}

var (
	enhancedUserMetaServiceServers     = make(map[string]UserMetaServiceEnhancedServer)
	enhancedUserMetaServiceServersLock = sync.RWMutex{}
)

type idUserMetaServiceServer interface {
	ID() string
}
type UserMetaServiceEnhancedServer interface {
	UserMetaServiceServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(UserMetaServiceServer)
	filter(context.Context) []UserMetaServiceServer
}
type UserMetaServiceEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []UserMetaServiceServer
}

func (m *UserMetaServiceEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *UserMetaServiceEnhancedServerImpl) addHandler(srv UserMetaServiceServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *UserMetaServiceEnhancedServerImpl) filter(ctx context.Context) []UserMetaServiceServer {
	var ret []UserMetaServiceServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *UserMetaServiceEnhancedServerImpl) UpdateUserMeta(ctx context.Context, r *UpdateUserMetaRequest) (*UpdateUserMetaResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.UpdateUserMeta(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserMeta not implemented")
}

func (m *UserMetaServiceEnhancedServerImpl) SearchUserMeta(r *SearchUserMetaRequest, s UserMetaService_SearchUserMetaServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.SearchUserMeta(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method SearchUserMeta not implemented")
}

func (m *UserMetaServiceEnhancedServerImpl) UpdateUserMetaNamespace(ctx context.Context, r *UpdateUserMetaNamespaceRequest) (*UpdateUserMetaNamespaceResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.UpdateUserMetaNamespace(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserMetaNamespace not implemented")
}

func (m *UserMetaServiceEnhancedServerImpl) ListUserMetaNamespace(r *ListUserMetaNamespaceRequest, s UserMetaService_ListUserMetaNamespaceServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.ListUserMetaNamespace(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method ListUserMetaNamespace not implemented")
}
func (m *UserMetaServiceEnhancedServerImpl) mustEmbedUnimplementedUserMetaServiceServer() {}
func RegisterUserMetaServiceEnhancedServer(s grpc.ServiceRegistrar, srv UserMetaServiceServer) {
	idServer, ok := s.(idUserMetaServiceServer)
	if ok {
		enhancedUserMetaServiceServersLock.Lock()
		defer enhancedUserMetaServiceServersLock.Unlock()
		instance, ok := enhancedUserMetaServiceServers[idServer.ID()]
		if !ok {
			instance = &UserMetaServiceEnhancedServerImpl{}
			enhancedUserMetaServiceServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterUserMetaServiceServer(s, instance)
	} else {
		RegisterUserMetaServiceServer(s, srv)
	}
}

var (
	enhancedPolicyEngineServiceServers     = make(map[string]PolicyEngineServiceEnhancedServer)
	enhancedPolicyEngineServiceServersLock = sync.RWMutex{}
)

type idPolicyEngineServiceServer interface {
	ID() string
}
type PolicyEngineServiceEnhancedServer interface {
	PolicyEngineServiceServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(PolicyEngineServiceServer)
	filter(context.Context) []PolicyEngineServiceServer
}
type PolicyEngineServiceEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []PolicyEngineServiceServer
}

func (m *PolicyEngineServiceEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *PolicyEngineServiceEnhancedServerImpl) addHandler(srv PolicyEngineServiceServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *PolicyEngineServiceEnhancedServerImpl) filter(ctx context.Context) []PolicyEngineServiceServer {
	var ret []PolicyEngineServiceServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *PolicyEngineServiceEnhancedServerImpl) IsAllowed(ctx context.Context, r *PolicyEngineRequest) (*PolicyEngineResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.IsAllowed(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method IsAllowed not implemented")
}

func (m *PolicyEngineServiceEnhancedServerImpl) StorePolicyGroup(ctx context.Context, r *StorePolicyGroupRequest) (*StorePolicyGroupResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.StorePolicyGroup(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method StorePolicyGroup not implemented")
}

func (m *PolicyEngineServiceEnhancedServerImpl) ListPolicyGroups(ctx context.Context, r *ListPolicyGroupsRequest) (*ListPolicyGroupsResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.ListPolicyGroups(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method ListPolicyGroups not implemented")
}

func (m *PolicyEngineServiceEnhancedServerImpl) StreamPolicyGroups(r *ListPolicyGroupsRequest, s PolicyEngineService_StreamPolicyGroupsServer) error {
	for _, handler := range m.filter(s.Context()) {
		return handler.StreamPolicyGroups(r, s)
	}
	return status.Errorf(codes.Unimplemented, "method StreamPolicyGroups not implemented")
}

func (m *PolicyEngineServiceEnhancedServerImpl) DeletePolicyGroup(ctx context.Context, r *DeletePolicyGroupRequest) (*DeletePolicyGroupResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.DeletePolicyGroup(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method DeletePolicyGroup not implemented")
}
func (m *PolicyEngineServiceEnhancedServerImpl) mustEmbedUnimplementedPolicyEngineServiceServer() {}
func RegisterPolicyEngineServiceEnhancedServer(s grpc.ServiceRegistrar, srv PolicyEngineServiceServer) {
	idServer, ok := s.(idPolicyEngineServiceServer)
	if ok {
		enhancedPolicyEngineServiceServersLock.Lock()
		defer enhancedPolicyEngineServiceServersLock.Unlock()
		instance, ok := enhancedPolicyEngineServiceServers[idServer.ID()]
		if !ok {
			instance = &PolicyEngineServiceEnhancedServerImpl{}
			enhancedPolicyEngineServiceServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterPolicyEngineServiceServer(s, instance)
	} else {
		RegisterPolicyEngineServiceServer(s, srv)
	}
}
