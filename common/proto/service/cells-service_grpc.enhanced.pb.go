// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             (unknown)
// source: cells-service.proto

package service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	sync "sync"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

var (
	enhancedServiceManagerServers     = make(map[string]ServiceManagerEnhancedServer)
	enhancedServiceManagerServersLock = sync.RWMutex{}
)

type idServiceManagerServer interface {
	ID() string
}
type ServiceManagerEnhancedServer interface {
	ServiceManagerServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(ServiceManagerServer)
	filter(context.Context) []ServiceManagerServer
}
type ServiceManagerEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []ServiceManagerServer
}

func (m *ServiceManagerEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *ServiceManagerEnhancedServerImpl) addHandler(srv ServiceManagerServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *ServiceManagerEnhancedServerImpl) filter(ctx context.Context) []ServiceManagerServer {
	var ret []ServiceManagerServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *ServiceManagerEnhancedServerImpl) Start(ctx context.Context, r *StartRequest) (*StartResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Start(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}

func (m *ServiceManagerEnhancedServerImpl) Stop(ctx context.Context, r *StopRequest) (*StopResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Stop(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (m *ServiceManagerEnhancedServerImpl) mustEmbedUnimplementedServiceManagerServer() {}
func RegisterServiceManagerEnhancedServer(s grpc.ServiceRegistrar, srv ServiceManagerServer) {
	idServer, ok := s.(idServiceManagerServer)
	if ok {
		enhancedServiceManagerServersLock.Lock()
		defer enhancedServiceManagerServersLock.Unlock()
		instance, ok := enhancedServiceManagerServers[idServer.ID()]
		if !ok {
			instance = &ServiceManagerEnhancedServerImpl{}
			enhancedServiceManagerServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterServiceManagerServer(s, instance)
	} else {
		RegisterServiceManagerServer(s, srv)
	}
}

var (
	enhancedArchiverServers     = make(map[string]ArchiverEnhancedServer)
	enhancedArchiverServersLock = sync.RWMutex{}
)

type idArchiverServer interface {
	ID() string
}
type ArchiverEnhancedServer interface {
	ArchiverServer
	AddFilter(func(context.Context, interface{}) bool)
	addHandler(ArchiverServer)
	filter(context.Context) []ArchiverServer
}
type ArchiverEnhancedServerImpl struct {
	filters  []func(context.Context, interface{}) bool
	handlers []ArchiverServer
}

func (m *ArchiverEnhancedServerImpl) AddFilter(f func(context.Context, interface{}) bool) {
	m.filters = append(m.filters, f)
}
func (m *ArchiverEnhancedServerImpl) addHandler(srv ArchiverServer) {
	m.handlers = append(m.handlers, srv)
}
func (m *ArchiverEnhancedServerImpl) filter(ctx context.Context) []ArchiverServer {
	var ret []ArchiverServer
	for _, i := range m.handlers {
		valid := true
		for _, filter := range m.filters {
			if !filter(ctx, i) {
				valid = false
				break
			}
			if valid {
				ret = append(ret, i)
			}
		}
	}
	return ret
}

func (m *ArchiverEnhancedServerImpl) Archive(ctx context.Context, r *Query) (*ArchiveResponse, error) {
	for _, handler := range m.filter(ctx) {
		return handler.Archive(ctx, r)
	}
	return nil, status.Errorf(codes.Unimplemented, "method Archive not implemented")
}
func (m *ArchiverEnhancedServerImpl) mustEmbedUnimplementedArchiverServer() {}
func RegisterArchiverEnhancedServer(s grpc.ServiceRegistrar, srv ArchiverServer) {
	idServer, ok := s.(idArchiverServer)
	if ok {
		enhancedArchiverServersLock.Lock()
		defer enhancedArchiverServersLock.Unlock()
		instance, ok := enhancedArchiverServers[idServer.ID()]
		if !ok {
			instance = &ArchiverEnhancedServerImpl{}
			enhancedArchiverServers[idServer.ID()] = instance
		}
		instance.addHandler(srv)
		RegisterArchiverServer(s, instance)
	} else {
		RegisterArchiverServer(s, srv)
	}
}
